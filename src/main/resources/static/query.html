<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Query - QueryBot (Conversations)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <style>
        body { font-family: Inter, Arial, sans-serif; background:#f6f8fb; margin:0; padding:0; }
        .app { max-width:900px; margin:24px auto; background:#fff; border-radius:10px; box-shadow:0 6px 20px rgba(23,31,50,0.08); overflow:hidden; }
        header { padding:16px 20px; border-bottom:1px solid #eef2f7; display:flex; align-items:center; gap:12px }
        header h1 { margin:0; font-size:18px; }
        .chat { height: 64vh; overflow:auto; padding:18px; background: linear-gradient(180deg,#fbfdff,#f7fbff); }
        .msg { max-width:78%; padding:10px 14px; margin-bottom:10px; border-radius:12px; line-height:1.35; }
        .user { background:#0b93f6; color:#fff; margin-left:auto; border-bottom-right-radius:2px; }
        .assistant { background:#f1f5f9; color:#0f1724; margin-right:auto; }
        .meta { font-size:12px; color:#6b7280; margin-top:6px; }
        .composer { display:flex; gap:8px; padding:12px; border-top:1px solid #eef2f7; background:#fff; }
        .composer input[type=text] { flex:1; padding:10px 12px; border-radius:8px; border:1px solid #e6eef8; font-size:14px; }
        .composer button { padding:10px 14px; border-radius:8px; border:0; background:#0b93f6; color:#fff; cursor:pointer; }
        .sql { font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', monospace; background:#0f1724; color:#e2e8f0; padding:10px; border-radius:8px; margin-top:8px; font-size:13px; }
        .table-wrap { margin-top:10px; overflow:auto; border-radius:8px; border:1px solid #eef2f7; }
        table.results { border-collapse:collapse; width:100%; font-size:13px; }
        table.results th, table.results td { border-bottom:1px solid #eef2f7; padding:8px 10px; text-align:left; }
        .typing { display:inline-block; width:36px; height:12px; vertical-align:middle }
        .dot { display:inline-block, width:6px, height:6px; margin:0 2px; background:#9aa6b2; border-radius:50%; opacity:0.8; animation:dot 1s infinite; }
        .dot.d1 { animation-delay:0s } .dot.d2 { animation-delay:0.15s } .dot.d3 { animation-delay:0.3s }
        @keyframes dot { 0% { transform:translateY(0) } 50% { transform:translateY(-4px) } 100% { transform:translateY(0) } }
        .small { font-size:12px; color:#475569 }
        ul { margin:0; padding-left:20px; list-style:disc; }
        li { margin:4px 0; }
        .modal-overlay { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:1000; justify-content:center; align-items:center; }
        .modal-overlay.active { display:flex; }
        .modal-content { background:#fff; border-radius:10px; max-width:80%; max-height:80vh; overflow:auto; box-shadow:0 10px 40px rgba(0,0,0,0.2); padding:20px; position:relative; }
        .modal-close { position:absolute; top:10px; right:15px; font-size:28px; font-weight:bold; cursor:pointer; color:#666; }
        .modal-close:hover { color:#000; }
        .modal-title { margin-top:0; margin-bottom:15px; font-size:18px; font-weight:bold; }
    </style>
</head>
<body>
<div class="app">
    <header>
        <h1>QueryBot — Conversational SQL assistant</h1>
    </header>

    <div id="chat" class="chat" role="log" aria-live="polite"></div>


    <!-- Upload confirmation modal (replaces native confirm) -->
    <div id="uploadModal" class="modal-overlay">
        <div class="modal-content" style="max-width:480px;">
            <span class="modal-close" onclick="closeUploadModal()">&times;</span>
            <h3 class="modal-title">Upload file</h3>
            <div id="uploadModalBody">Upload this file: <strong id="uploadFileName"></strong></div>
            <div style="margin-top:12px; text-align:right;">
                <button id="uploadCancelBtn" style="background:#bbb; padding:8px 12px; border-radius:6px; margin-right:8px;">Cancel</button>
                <button id="uploadConfirmBtn" style="background:#10b981; color:#fff; padding:8px 12px; border-radius:6px;">Upload</button>
            </div>
        </div>
    </div>

    <form id="composer" class="composer" autocomplete="off">
        <input id="nl" name="nl" type="text" placeholder="Ask something (e.g. 'show top 5 by amount') — press Enter to send" required />
        <button type="submit">Send</button>
        <!-- Upload button: opens file picker and uploads to /api/files/upload (CSV, Excel, JSON) -->
        <button type="button" id="uploadBtn" style="background:#10b981; color:#fff; border:0; padding:10px 12px; border-radius:8px; cursor:pointer;">Upload Data</button>
        <input id="fileInput" type="file" accept=".csv,.xlsx,.xls,.json" style="display:none" />
    </form>
</div>

<script>
    const chat = document.getElementById('chat');
    const composer = document.getElementById('composer');
    const nlInput = document.getElementById('nl');
    const uploadBtn = document.getElementById('uploadBtn');
    const fileInput = document.getElementById('fileInput');

    function appendMessage(role, htmlContent, opts={}){
        const wrap = document.createElement('div');
        wrap.className = 'msg ' + (role === 'user' ? 'user' : 'assistant');
        wrap.innerHTML = htmlContent;
        chat.appendChild(wrap);
        chat.scrollTop = chat.scrollHeight - chat.clientHeight + 100;
        return wrap;
    }

    async function loadHistory(){
        try{
            const resp = await fetch('/api/query/history', { credentials: 'include' });
            if (!resp.ok) return;
            const conv = await resp.json();
            if (!Array.isArray(conv) || conv.length === 0) return;
            // render oldest->newest
            conv.forEach(m => {
                if (!m || !m.role) return;
                if (m.role === 'user') appendUser(m.content);
                else appendAssistantText(m.content);
            });
        }catch(e){ /* ignore */ }
    }

    function appendUser(text){
        appendMessage('user', escapeHtml(text));
    }

    function parseMarkdown(text) {
        // First escape HTML for safety
        let html = escapeHtml(text);

        // Convert **bold** to <strong>bold</strong>
        html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');

        // Convert *italic* or _italic_ to <em>italic</em>
        html = html.replace(/\*([^\*]+)\*/g, '<em>$1</em>');
        html = html.replace(/_([^_]+)_/g, '<em>$1</em>');

        // Handle lists (both numbered and bullet) more carefully to avoid indentation issues
        // Find all list blocks and convert them
        const listBlockRegex = /(?:^|\n)((?:(?:\d+\.|-).*\n?)+)/gm;
        html = html.replace(listBlockRegex, (match) => {
            const lines = match.trim().split('\n');
            let listHtml = '<ul>';
            lines.forEach(line => {
                // Remove leading dash or number from the line
                const cleanLine = line.replace(/^\d+\.\s+/, '').replace(/^-\s+/, '');
                if (cleanLine) {
                    listHtml += '<li>' + cleanLine + '</li>';
                }
            });
            listHtml += '</ul>';
            return '\n' + listHtml + '\n';
        });

        // Convert remaining line breaks to <br>, but avoid double breaks around lists
        html = html.replace(/\n\n+/g, '<br>'); // multiple line breaks become single <br>
        html = html.replace(/\n(?=<ul>)/g, ''); // remove newline before <ul>
        html = html.replace(/(<\/ul>)\n/g, '$1'); // remove newline after </ul>

        return html;
    }

    function appendAssistantText(text){
        const html = parseMarkdown(text);
        const el = appendMessage('assistant', '<div>'+html+'</div>');
        return el;
    }

    function showTyping(){
        const el = appendMessage('assistant', '<div class="typing"><span class="dot d1"></span><span class="dot d2"></span><span class="dot d3"></span></div>');
        return el;
    }

    function escapeHtml(s){
        return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    function openModal(sqlContent, tableHtml) {
        let content = '';
        if (sqlContent) {
            content += '<div style="margin-bottom:12px;"><strong>SQL Query:</strong><div class="sql">' + escapeHtml(sqlContent) + '</div></div>';
        }
        if (tableHtml) {
            content += '<div><strong>Results:</strong>' + tableHtml + '</div>';
        }
        if (content) {
            appendMessage('assistant', content);
        }
    }

    function closeModal() {
        // no longer needed for inline display
    }

    function escapeHtml(s){
        return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    composer.addEventListener('submit', async (e) => {
        e.preventDefault();
        const text = nlInput.value && nlInput.value.trim();
        if (!text) return;
        nlInput.value = '';
        appendUser(text);

        const typingEl = showTyping();

        try {
            const resp = await fetch('/api/query/nl', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ nlQuery: text })
            });
            const body = await resp.json();
            // remove typing indicator
            typingEl.remove();

            if (!resp.ok) {
                appendAssistantText('Error: ' + (body?.message || JSON.stringify(body)));
                return;
            }

            // Assistant natural-language answer (summary)
            if (body?.nlAnswer) appendAssistantText(body.nlAnswer);

            // Decide whether to auto-show SQL/table: only when the user explicitly asks to show or display
            const showKeywords = /\b(show|show me|show sql|show table|show rows|display|display me|display the|display rows|list rows|table format|in table|table view)\b/i;
            const shouldAutoShow = showKeywords.test(text);

            // Collect SQL and table for inline display
            let sqlContent = '';
            let tableHtml = '';

            // SQL: collect for inline display
            if (body?.sql && shouldAutoShow) {
                sqlContent = body.sql;
            }

            // Table rows: collect for inline display
            const rows = body?.rows || [];
            if (rows.length > 0 && shouldAutoShow) {
                const cols = Object.keys(rows[0]);
                tableHtml = '<div class="table-wrap"><table class="results"><thead><tr>';
                cols.forEach(c => tableHtml += '<th>'+escapeHtml(c)+'</th>');
                tableHtml += '</tr></thead><tbody>';
                rows.forEach(r => {
                    tableHtml += '<tr>';
                    cols.forEach(c => tableHtml += '<td>'+escapeHtml(r[c] ?? '')+'</td>');
                    tableHtml += '</tr>';
                });
                tableHtml += '</tbody></table></div>';
            }

            // Display SQL and table inline in chat
            if (shouldAutoShow && (sqlContent || tableHtml)) {
                openModal(sqlContent, tableHtml);
            } else if (!rows.length && shouldAutoShow) {
                appendAssistantText('(no rows returned)');
            }

        } catch (err) {
            try { typingEl.remove(); } catch(e){}
            appendAssistantText('Request failed: ' + err);
        } finally {
            nlInput.focus();
        }
    });

    // small helper: press Enter to send, Shift+Enter for newline (supports multi-line if you change input to textarea later)
    nlInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            composer.requestSubmit();
        }
    });

    // Load existing conversation from server memory then show a hint if empty
    (async ()=>{ await loadHistory();
        // if no messages rendered, show a friendly starter
        if (chat.children.length === 0) {
            appendAssistantText('Hello — I can help query the latest uploaded table. Ask follow-ups like "show the next two" or "sort that ascending".');
        }
    })();
    nlInput.focus();

    // Upload button handler: open file picker
    uploadBtn.addEventListener('click', () => fileInput.click());

    // File upload handling: show a custom modal to confirm upload then POST to /api/files/upload
    let _selectedUploadFile = null;
    fileInput.addEventListener('change', (e) => {
        const files = Array.from(e.target.files || []);
        if (files.length === 0) return;
        _selectedUploadFile = files[0];
        // show custom modal instead of native confirm
        document.getElementById('uploadFileName').textContent = _selectedUploadFile.name;
        document.getElementById('uploadModal').classList.add('active');
    });

    document.getElementById('uploadCancelBtn').addEventListener('click', () => {
        // close and reset selection
        closeUploadModal();
        fileInput.value = '';
        _selectedUploadFile = null;
    });

    document.getElementById('uploadConfirmBtn').addEventListener('click', async () => {
        if (!_selectedUploadFile) return closeUploadModal();
        closeUploadModal();
        const file = _selectedUploadFile;
        appendAssistantText('Uploading ' + file.name + '...');

        const formData = new FormData();
        formData.append('file', file);
        try {
            const resp = await fetch('/api/files/upload', { method: 'POST', body: formData, credentials: 'include' });
            if (!resp.ok) {
                const errText = await resp.text();
                appendAssistantText('Upload failed: ' + errText);
                return;
            }
            const info = await resp.json();
            const tableName = info?.tableName || file.name;
            const rowCount = info?.rowCount || 0;

            // Store a FACT in session memory so subsequent queries can use it
            await fetch('/api/query/memory', {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({ role: 'assistant', content: 'Uploaded table: ' + tableName + ' rows=' + rowCount })
            });

            // show a formatted message: tableName is escaped, but we render HTML for emphasis
            appendMessage('assistant', 'Uploaded and imported as <strong>' + escapeHtml(tableName) + '</strong> (' + rowCount + ' rows)');
        } catch (err) {
            appendAssistantText('Upload error: ' + (err && err.message ? err.message : err));
        } finally {
            // reset file input and local selection
            fileInput.value = '';
            _selectedUploadFile = null;
            nlInput.focus();
        }
    });

    function closeUploadModal() {
        document.getElementById('uploadModal').classList.remove('active');
    }
</script>
</body>
</html>